#include<stdio.h>
int main(){
/* 
类型转换与优先级

（一）类型转换
	1.分类：（表达式中发生的类型转换）
	  1.1赋值符左右两侧的类型不同
	  1.2不同类型的混合运算
	2.例题：
	  2.1类型不同
	    unsigned char a = 0x1234;//int->unsigned char
	    int n = 123.456;//double -> int
	  2.2混合运算
	    double x = 99.10 + 5;
	3.数据丢失问题：类型不同类型转换的数据丢失
	  3.1整型之间的转换，超出范围会被截断(把大数赋给体积小的变量)
	     unsigned char b = 0x12345678;//0-255,高位丢失,显示0x78'x'
	  3.2小数转整数，小数部分会丢失（用范围大的类型保存大数，小数部分丢失）
	     int b = 123.345;//局部变量显示123，不是四舍五入而是直接丢掉
	4.隐式转换：
	  表达式中各种类型混合运算时，编译器会自动类型提升，不提升会丢数据
	  4.1char与short一起运算会被提升为short
	  4.2int与double一起运算int会被自动提升为double
	     double a = 10 + 0.5;线提升再相加
	5.显示转换：
	  5.1两个整数相除得到小数类型：
	     int a = 3;
	     int b = 10;
	     double result = 0.0000000000000000；不转换结果为0
	     double result = (double)3 / 10;//0.2999999999999999
		 注意与3.0/10的区别：将3提升为double型以便结果能够保存小数
	  5.2打印double类型需要%f,若写成%d则会出现任意结果
	     printf("%d \n",10+0.3);
（二）优先级的问题
    1.多个运算符构成的混合表达式需要考虑优先级问题：
	  1.1 算数运算符与实际一致
	  1.2 运算符在表中排好很难背
	  1.3 强制加小括号，可读性强（没把握的顺序统一用括号）
	  1.4 记住少数几种优先级顺序
	2.例题：
	  int c = 10;
	  int d = 200;
	  printf("%d \n", (c+d)>100);//1
	  printf("%d \n", c + d> 100);//1
	  printf("%d \n", c +( d > 100));//11：10+1（真）
	3.规则：
	  3.1 算数优先级顺序
	      （* 、/ 最高）
	  3.2 逻辑运算优先级
	      （！最高，&&次之，||再次）
	  3.3 终极解决方案：
	      积极使用小括号，对没把握的优先级顺序统一使用小括号
（三）小结
	1.数据丢失问题：用大容量变量存储数据
	2.类型提升问题：
	3.优先级问题：没人能记住上百种操作符，
	            即便记住写出来也是不宜读代码，
	            不要把难读的代码留给别人
	*/





























	return 0;
}



